name: Test Sandboxed Step

on: [push, pull_request]

jobs:
  test-token-detection:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout with persisted credentials (default)
        uses: actions/checkout@v4
        # Intentionally NOT setting persist-credentials: false to test detection

      - name: Test token detection (should fail)
        id: token-test
        uses: ./
        continue-on-error: true
        with:
          run: |
            echo "This should not run - token detection should fail"

      - name: Verify token detection worked
        run: |
          if [ "${{ steps.token-test.outcome }}" != "failure" ]; then
            echo "ERROR: Action should have failed due to persisted credentials!"
            echo "Outcome was: ${{ steps.token-test.outcome }}"
            exit 1
          fi
          echo "✓ Good! Token detection correctly prevented sandbox execution"

      - name: Clear persisted credentials
        run: |
          # Remove the persisted credentials from git config
          if [ -f .git/config ]; then
            git config --unset-all http.https://github.com/.extraheader || true
          fi

      - name: Test sandbox runs without persisted credentials
        uses: ./
        with:
          run: |
            echo "✓ Sandbox runs successfully without persisted credentials"

      - name: Re-checkout with persisted credentials
        uses: actions/checkout@v4
        # Intentionally keeping default persist-credentials: true

      - name: Test with allow-checkout-credentials option
        uses: ./
        with:
          allow-checkout-credentials: true
          run: |
            echo "✓ Sandbox runs with allow-checkout-credentials: true (warning should be shown)"

  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Run normal command (not sandboxed)
        run: |
          echo "This is not sandboxed"
          echo "Current user: $(whoami)"
          echo "User ID: $(id -u), Group ID: $(id -g)"
          echo "Home directory: $HOME"
          echo "Hostname: $(hostname)"
          echo "HOSTNAME_FOR_TEST=$(hostname)" >> $GITHUB_ENV
          echo "Can access network: $(curl -s -o /dev/null -w '%{http_code}' https://github.com)"

      - name: Run sandboxed command
        uses: ./
        with:
          run: |
            echo "This is sandboxed"
            echo "Current user: $(whoami)"
            echo "User ID: $(id -u), Group ID: $(id -g)"
            echo "Home directory: $HOME"
            echo "Hostname in sandbox: $(hostname)"
            echo "Expected hostname: $HOSTNAME_FOR_TEST"
            if [ "$(hostname)" = "$HOSTNAME_FOR_TEST" ]; then
              echo "✓ Hostname matches host system"
            else
              echo "✗ Hostname mismatch! Sandbox: $(hostname), Host: $HOSTNAME_FOR_TEST"
            fi
            # Test sudo access (must be available)
            echo "Testing sudo access:"
            sudo echo "✓ Passwordless sudo works!"
            echo "OS Info:"
            cat /etc/os-release | grep -E "^(NAME|VERSION)" | head -2

      - name: Test network connectivity
        uses: ./
        with:
          run: |
            echo "=== Testing network connectivity ==="
            echo "Using apt-get update to verify network access..."
            sudo apt-get update && echo "✓ Network connectivity verified - apt-get update successful"

      - name: Test file operations in sandbox
        uses: ./
        with:
          run: |
            echo "Testing file operations in sandbox"
            echo "Creating a test file in /tmp"
            echo "Hello from sandbox" > /tmp/test.txt
            cat /tmp/test.txt
            rm /tmp/test.txt
            echo "File operations completed"

      - name: Test workspace access in sandbox
        uses: ./
        with:
          run: |
            echo "Testing workspace access"
            echo "Current directory: $(pwd)"
            echo "GitHub workspace: $GITHUB_WORKSPACE"
            echo "Verifying we are in the GitHub workspace:"
            if [ "$(pwd)" = "$GITHUB_WORKSPACE" ]; then
              echo "✓ Working directory matches GitHub workspace"
            else
              echo "✗ Working directory mismatch!"
              exit 1
            fi
            echo ""
            echo "Workspace contents:"
            ls -la
            echo ""
            echo "Can read existing files (action.yml first 5 lines):"
            head -5 action.yml
            echo ""
            echo "Creating a file in workspace from sandbox (should go to overlay)"
            echo "Created by sandbox at $(date)" > sandbox-test-file.txt
            echo "File created in sandbox, verifying it exists inside:"
            ls -l sandbox-test-file.txt
            cat sandbox-test-file.txt

      - name: Test environment variables in sandbox
        uses: ./
        with:
          run: |
            echo "Testing environment variables in sandbox"
            echo "CI=$CI"
            echo "GITHUB_ACTIONS=$GITHUB_ACTIONS"
            echo "GITHUB_REPOSITORY=$GITHUB_REPOSITORY"
            echo "GITHUB_SHA=$GITHUB_SHA"
            echo "RUNNER_OS=$RUNNER_OS"
            echo "PATH=$PATH"

      - name: Test custom environment variables
        uses: ./
        with:
          env: |
            MY_CUSTOM_VAR=hello_world
            TEST_DATABASE_URL=postgres://test:5432/db
            NUMERIC_VAR=42
            EMPTY_VAR=
            VAR_WITH_QUOTES=This "has quotes" in it
            JSON_STRING={"key": "value", "number": 123}
          run: |
            echo "Testing custom environment variables"
            # Check that custom vars are set
            if [ "$MY_CUSTOM_VAR" = "hello_world" ]; then
              echo "✓ MY_CUSTOM_VAR is correctly set: $MY_CUSTOM_VAR"
            else
              echo "ERROR: MY_CUSTOM_VAR not set correctly. Got: '$MY_CUSTOM_VAR'"
              exit 1
            fi

            if [ "$TEST_DATABASE_URL" = "postgres://test:5432/db" ]; then
              echo "✓ TEST_DATABASE_URL is correctly set: $TEST_DATABASE_URL"
            else
              echo "ERROR: TEST_DATABASE_URL not set correctly. Got: '$TEST_DATABASE_URL'"
              exit 1
            fi

            if [ "$NUMERIC_VAR" = "42" ]; then
              echo "✓ NUMERIC_VAR is correctly set: $NUMERIC_VAR"
            else
              echo "ERROR: NUMERIC_VAR not set correctly. Got: '$NUMERIC_VAR'"
              exit 1
            fi

            if [ -z "$EMPTY_VAR" ]; then
              echo "✓ EMPTY_VAR is correctly empty"
            else
              echo "ERROR: EMPTY_VAR should be empty. Got: '$EMPTY_VAR'"
              exit 1
            fi

            # Test variable with quotes
            if [ "$VAR_WITH_QUOTES" = 'This "has quotes" in it' ]; then
              echo "✓ VAR_WITH_QUOTES correctly handles quotes: $VAR_WITH_QUOTES"
            else
              echo "ERROR: VAR_WITH_QUOTES not set correctly. Got: '$VAR_WITH_QUOTES'"
              exit 1
            fi

            # Test JSON string with quotes and special characters
            if [ "$JSON_STRING" = '{"key": "value", "number": 123}' ]; then
              echo "✓ JSON_STRING correctly handles JSON: $JSON_STRING"
            else
              echo "ERROR: JSON_STRING not set correctly. Got: '$JSON_STRING'"
              exit 1
            fi

            # Verify these custom vars don't leak to host
            echo "Custom vars processed successfully"

      - name: Verify custom env vars don't leak to host
        run: |
          echo "Verifying custom environment variables don't exist on host"
          if [ -z "${MY_CUSTOM_VAR:-}" ]; then
            echo "✓ MY_CUSTOM_VAR does not exist on host (good)"
          else
            echo "ERROR: MY_CUSTOM_VAR leaked to host: $MY_CUSTOM_VAR"
            exit 1
          fi

          if [ -z "${TEST_DATABASE_URL:-}" ]; then
            echo "✓ TEST_DATABASE_URL does not exist on host (good)"
          else
            echo "ERROR: TEST_DATABASE_URL leaked to host: $TEST_DATABASE_URL"
            exit 1
          fi

      - name: Verify overlay isolation (file should NOT exist on host)
        run: |
          echo "Verifying file created in sandbox is NOT visible on host (overlay isolation)"
          if [ -f sandbox-test-file.txt ]; then
            echo "ERROR: File exists on host! Overlay isolation failed!"
            cat sandbox-test-file.txt
            rm sandbox-test-file.txt
            exit 1
          else
            echo "✓ Good! File not found on host - overlay isolation working correctly"
          fi

      - name: Create test file on host
        run: echo "Original host content" > test-modify.txt

      - name: Modify file in sandbox (changes should stay in overlay)
        uses: ./
        with:
          run: |
            echo "Reading existing file from host:"
            cat test-modify.txt
            echo ""
            echo "Modifying file in sandbox (changes go to overlay):"
            echo "Added by sandbox" >> test-modify.txt
            echo "File content inside sandbox after modification:"
            cat test-modify.txt

      - name: Verify host file unchanged (overlay isolation)
        run: |
          echo "Checking host file (should be unchanged due to overlay):"
          cat test-modify.txt
          if grep -q "Added by sandbox" test-modify.txt; then
            echo "ERROR: Host file was modified! Overlay isolation failed!"
            exit 1
          else
            echo "✓ Good! Host file unchanged - overlay isolation working correctly"
          fi
          rm test-modify.txt

      - name: Test command failure handling (should fail)
        id: failure-test
        uses: ./
        continue-on-error: true
        with:
          run: |
            echo "This command will fail"
            exit 1

      - name: Verify failure was detected
        run: |
          if [ "${{ steps.failure-test.outcome }}" != "failure" ]; then
            echo "ERROR: Failed command did not fail the action!"
            echo "Outcome was: ${{ steps.failure-test.outcome }}"
            exit 1
          fi
          echo "✓ Good! Failed command correctly failed the action"

      - name: Test missing command failure (should fail)
        id: missing-command-test
        uses: ./
        continue-on-error: true
        with:
          run: |
            echo "Trying to run a command that doesn't exist"
            this-command-does-not-exist

      - name: Verify missing command failure
        run: |
          if [ "${{ steps.missing-command-test.outcome }}" != "failure" ]; then
            echo "ERROR: Missing command did not fail the action!"
            echo "Outcome was: ${{ steps.missing-command-test.outcome }}"
            exit 1
          fi
          echo "✓ Good! Missing command correctly failed the action"

      - name: Verify sandbox isolation
        uses: ./
        with:
          run: |
            echo "Testing sandbox isolation"
            # Check filesystem isolation
            echo "Root filesystem contents:"
            ls / | head -20
            # Try to write to root (should work since rootfs is read-write)
            echo "test" > /test-file && echo "Successfully wrote to /test-file" && rm /test-file
            # Check process isolation
            echo "Process list (should only show sandbox processes):"
            ls /proc/[0-9]* 2>/dev/null | wc -l

      - name: Test read-only access pattern
        run: |
          echo "Creating test files for read-only verification"
          echo "Host file 1" > readonly-test-1.txt
          echo "Host file 2" > readonly-test-2.txt

      - name: Verify sandbox can read but changes don't persist
        uses: ./
        with:
          run: |
            echo "Reading host files:"
            cat readonly-test-1.txt
            cat readonly-test-2.txt
            echo ""
            echo "Deleting file 1 in sandbox (should work in overlay):"
            rm readonly-test-1.txt
            echo "File 1 deleted in sandbox"
            echo ""
            echo "Modifying file 2 in sandbox:"
            echo "Modified in sandbox" > readonly-test-2.txt
            cat readonly-test-2.txt

      - name: Verify host files are intact
        run: |
          echo "Checking host files after sandbox operations:"
          if [ -f readonly-test-1.txt ]; then
            echo "✓ File 1 still exists on host (good!)"
            cat readonly-test-1.txt
          else
            echo "ERROR: File 1 was deleted from host!"
            exit 1
          fi
          echo ""
          if grep -q "Host file 2" readonly-test-2.txt; then
            echo "✓ File 2 unchanged on host (good!)"
            cat readonly-test-2.txt
          else
            echo "ERROR: File 2 was modified on host!"
            cat readonly-test-2.txt
            exit 1
          fi
          rm readonly-test-1.txt readonly-test-2.txt

      - name: Test workspace persistence when enabled
        uses: ./
        with:
          persist-workspace-changes: true
          run: |
            echo "Testing workspace persistence (persist-workspace-changes: true)"
            echo "Creating a file that should persist on host"
            echo "Created with persist-workspace-changes enabled" > persisted-file.txt
            echo "File created in sandbox with persistence enabled"

      - name: Verify file persisted on host
        run: |
          echo "Checking if file created with persist-workspace-changes exists on host:"
          if [ -f persisted-file.txt ]; then
            echo "✓ Good! File persisted on host as expected"
            cat persisted-file.txt
            # Verify content
            if grep -q "Created with persist-workspace-changes enabled" persisted-file.txt; then
              echo "✓ File content is correct"
            else
              echo "ERROR: File content is incorrect!"
              exit 1
            fi
            rm persisted-file.txt
          else
            echo "ERROR: File did not persist on host!"
            exit 1
          fi

      - name: Test modification persistence when enabled
        run: echo "Original content for persistence test" > persist-modify-test.txt

      - name: Modify file with persistence enabled
        uses: ./
        with:
          persist-workspace-changes: true
          run: |
            echo "Modifying file with persist-workspace-changes enabled:"
            echo "Modified with persistence" >> persist-modify-test.txt
            cat persist-modify-test.txt

      - name: Verify modification persisted
        run: |
          echo "Checking if modification persisted:"
          cat persist-modify-test.txt
          if grep -q "Modified with persistence" persist-modify-test.txt; then
            echo "✓ Good! Modification persisted on host"
          else
            echo "ERROR: Modification did not persist!"
            exit 1
          fi
          rm persist-modify-test.txt

      - name: Test package installation in Ubuntu environment
        uses: ./
        with:
          run: |
            echo "Testing package installation in Ubuntu 24.04 sandbox"
            echo "Updating package list..."
            sudo apt-get update
            echo "Installing curl..."
            sudo apt-get install -y curl
            echo "Testing curl after installation..."
            curl --version
            echo "✓ Successfully installed and tested curl"

      - name: Test network isolation (should fail to connect)
        uses: ./
        with:
          disable-network: true
          run: |
            echo "Testing network isolation (network should be disabled)"
            # Try apt-get update and check for network failure messages
            OUTPUT=$(sudo apt-get update 2>&1)
            if echo "$OUTPUT" | grep -q "Temporary failure resolving"; then
              echo "✓ Good! Network is properly isolated (DNS resolution failed as expected)"
            else
              echo "ERROR: Expected network failure but didn't see DNS resolution errors!"
              echo "Output was:"
              echo "$OUTPUT"
              exit 1
            fi

      - name: Test network is enabled by default
        uses: ./
        with:
          run: |
            echo "Testing that network is enabled by default"
            # apt-get update should work with network
            sudo apt-get update && echo "✓ Network access verified (apt-get update successful)"

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Test Go is accessible in sandbox
        uses: ./
        with:
          run: |
            echo "Testing Go installed by setup-go is accessible in sandbox"
            echo "PATH in sandbox: $PATH"
            echo "RUNNER_TOOL_CACHE: ${RUNNER_TOOL_CACHE:-not set}"

            # Check if go is in PATH
            if ! command -v go &> /dev/null; then
              echo "ERROR: go command not found in PATH"
              exit 1
            fi

            # Check go version
            go version

            # Check that it's the right go (from tool cache)
            GO_PATH=$(which go)
            echo "Go binary location: $GO_PATH"

            if [[ "$GO_PATH" == *"$RUNNER_TOOL_CACHE"* ]]; then
              echo "✓ Go is correctly loaded from RUNNER_TOOL_CACHE"
            else
              echo "ERROR: Go is not from RUNNER_TOOL_CACHE"
              echo "Expected path to contain: $RUNNER_TOOL_CACHE"
              echo "Got: $GO_PATH"
              exit 1
            fi

            # Test that go actually works
            echo 'package main; import "fmt"; func main() { fmt.Println("Hello from Go in sandbox!") }' > test.go
            go run test.go
