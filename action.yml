name: 'gVisor Sandboxed Step'
description: 'Run commands in a gVisor sandbox'
author: 'geomys'
branding:
  icon: 'shield'
  color: 'green'

inputs:
  run:
    description: 'Commands to run in the sandbox'
    required: true
  allow-checkout-credentials:
    description: 'Allow running even if checkout action has persisted credentials (NOT RECOMMENDED)'
    required: false
    default: 'false'
  persist-workspace-changes:
    description: 'Allow changes to the workspace to persist on the host'
    required: false
    default: 'false'
  env:
    description: 'Additional environment variables to set in the sandbox (one per line, KEY=VALUE format)'
    required: false
    default: ''
  disable-network:
    description: 'Disable network access in the sandbox (default: false)'
    required: false
    default: 'false'
  rootfs-image:
    description: 'Docker image to use as the rootfs (default: ghcr.io/catthehacker/ubuntu:runner-24.04)'
    required: false
    default: 'ghcr.io/catthehacker/ubuntu:runner-24.04'

runs:
  using: 'composite'
  steps:
    - name: Run in sandbox
      shell: bash -e -o pipefail {0}
      run: |
        # Set up and run the gVisor sandbox

        # Check for persisted tokens from checkout action (unless explicitly allowed)
        if [ -f "${{ github.workspace }}/.git/config" ]; then
          # Check if git config contains authorization tokens
          if grep -q "AUTHORIZATION:" "${{ github.workspace }}/.git/config" 2>/dev/null; then
            if [ "${{ inputs.allow-checkout-credentials }}" != "true" ]; then
              echo "::error::Security Error: Detected persisted authentication token from checkout action"
              echo "::error::The checkout action has persisted credentials in .git/config which would be accessible inside the sandbox."
              echo "::error::To fix this, use 'persist-credentials: false' in your checkout step:"
              echo "::error::  - uses: actions/checkout@v4"
              echo "::error::    with:"
              echo "::error::      persist-credentials: false"
              exit 1
            else
              echo "::warning::Security warning: Detected persisted authentication token from checkout action"
              echo "::warning::You have chosen to allow persisted credentials inside the sandbox."
            fi
          fi
        fi

        # Create a working directory for the sandbox
        SANDBOX_DIR=$(mktemp -d /tmp/gvisor-sandbox-XXXXXX)

        # Download and extract Docker image as rootfs
        echo "Downloading rootfs image: ${{ inputs.rootfs-image }}..."
        mkdir -p "$SANDBOX_DIR/rootfs"

        # Pull the Docker image
        docker pull --platform linux/amd64 "${{ inputs.rootfs-image }}"

        # Create a container from the image (don't start it)
        CONTAINER_ID=$(docker create --platform linux/amd64 "${{ inputs.rootfs-image }}" /bin/true)

        # Export the container's filesystem
        echo "Extracting rootfs from Docker image..."
        # Use sudo to preserve file ownership and permissions (especially for setuid binaries like sudo)
        docker export "$CONTAINER_ID" | sudo tar -xp -C "$SANDBOX_DIR/rootfs"

        # Clean up the container
        docker rm "$CONTAINER_ID" > /dev/null

        # Setup basic requirements for the container
        echo "Setting up container environment..."

        # Copy host's DNS configuration for network access
        sudo cp /etc/resolv.conf "$SANDBOX_DIR/rootfs/etc/resolv.conf"

        # Create parent directories for workspace mount point
        WORKSPACE_DIR="${{ github.workspace }}"
        WORKSPACE_PARENT=$(dirname "$WORKSPACE_DIR")
        sudo mkdir -p "$SANDBOX_DIR/rootfs$WORKSPACE_PARENT"

        # Create mount point for RUNNER_TOOL_CACHE if it exists
        if [ -n "${RUNNER_TOOL_CACHE:-}" ] && [ -d "${RUNNER_TOOL_CACHE}" ]; then
          sudo mkdir -p "$SANDBOX_DIR/rootfs${RUNNER_TOOL_CACHE}"
        fi

        # Create the user script inside the rootfs
        sudo tee "$SANDBOX_DIR/rootfs/entrypoint.sh" > /dev/null << 'SANDBOXED_SCRIPT_EOF'
        #!/bin/bash
        set -euo pipefail  # Exit on any error, undefined variable, or pipe failure
        cd "${{ github.workspace }}"
        ${{ inputs.run }}
        SANDBOXED_SCRIPT_EOF

        sudo chmod +x "$SANDBOX_DIR/rootfs/entrypoint.sh"

        # Generate OCI config using the pre-built binary
        # Write the env input to a temporary file to safely handle quotes and newlines
        cat > "$SANDBOX_DIR/additional_env.txt" << 'SANDBOXED_ENV_EOF'
        ${{ inputs.env }}
        SANDBOXED_ENV_EOF
        # Only pass the file if it's not empty
        if [ -s "$SANDBOX_DIR/additional_env.txt" ]; then
          "${{ github.action_path }}/generate-config" "$SANDBOX_DIR/additional_env.txt" > "$SANDBOX_DIR/config.json"
        else
          "${{ github.action_path }}/generate-config" > "$SANDBOX_DIR/config.json"
        fi

        # Run the container with runsc
        CONTAINER_ID="sandbox-$$-$(date +%s)"

        echo "Starting sandbox container..."
        cd "$SANDBOX_DIR"
        # Configure overlay based on persist-workspace-changes setting
        # Note: Running runsc with sudo but container processes still run as runner user (not root)
        if [ "${{ inputs.persist-workspace-changes }}" = "true" ]; then
          echo "::warning::Workspace changes will persist on the host filesystem"
          # Use overlay only for root filesystem, not for bind mounts (workspace)
          OVERLAY_FLAGS="--overlay2=root:self"
        else
          # Use overlay for all mounts (including workspace) for full isolation
          OVERLAY_FLAGS="--overlay2=all:self"
        fi
        # Configure network based on disable-network setting
        if [ "${{ inputs.disable-network }}" = "true" ]; then
          echo "::notice::Network access disabled in sandbox"
          NETWORK_FLAGS="--network=none"
        else
          NETWORK_FLAGS="--network=host"
        fi
        # Add debug logging if RUNNER_DEBUG is set
        RUNSC_FLAGS="$NETWORK_FLAGS $OVERLAY_FLAGS --file-access-mounts=exclusive --allow-suid"
        if [ "${RUNNER_DEBUG:-0}" = "1" ]; then
          RUNSC_FLAGS="--debug --debug-log=/tmp/runsc-debug.log $RUNSC_FLAGS"
        fi
        # Run the sandbox and capture exit code
        EXIT_CODE=0
        sudo "${{ github.action_path }}/runsc" $RUNSC_FLAGS run "$CONTAINER_ID" || EXIT_CODE=$?

        # Clean up (always run, even if sandbox failed)
        cd /
        sudo rm -rf "$SANDBOX_DIR"

        # Exit with the same code as the sandbox
        if [ $EXIT_CODE -ne 0 ]; then
          echo "::error::Sandbox command failed with exit code $EXIT_CODE"
          exit $EXIT_CODE
        fi
