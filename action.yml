name: 'gVisor Sandboxed Step'
description: 'Run commands in a gVisor sandbox'
author: 'geomys'
branding:
  icon: 'shield'
  color: 'green'

inputs:
  run:
    description: 'Commands to run in the sandbox'
    required: true
  allow-checkout-credentials:
    description: 'Allow running even if checkout action has persisted credentials (NOT RECOMMENDED)'
    required: false
    default: 'false'
  persist-workspace-changes:
    description: 'Allow changes to the workspace to persist on the host'
    required: false
    default: 'false'
  env:
    description: 'Additional environment variables to set in the sandbox (one per line, KEY=VALUE format)'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Run in sandbox
      shell: bash
      run: |
        set -euo pipefail  # Exit on any error, undefined variable, or pipe failure

        # Check for persisted tokens from checkout action (unless explicitly allowed)
        if [ -f "${{ github.workspace }}/.git/config" ]; then
          # Check if git config contains authorization tokens
          if grep -q "AUTHORIZATION:" "${{ github.workspace }}/.git/config" 2>/dev/null; then
            if [ "${{ inputs.allow-checkout-credentials }}" != "true" ]; then
              echo "::error::Security Error: Detected persisted authentication token from checkout action"
              echo "::error::The checkout action has persisted credentials in .git/config which would be accessible inside the sandbox."
              echo "::error::To fix this, use 'persist-credentials: false' in your checkout step:"
              echo "::error::  - uses: actions/checkout@v4"
              echo "::error::    with:"
              echo "::error::      persist-credentials: false"
              exit 1
            else
              echo "::warning::Security warning: Detected persisted authentication token from checkout action"
              echo "::warning::You have chosen to allow persisted credentials inside the sandbox."
            fi
          fi
        fi

        # Create a working directory for the sandbox
        SANDBOX_DIR=$(mktemp -d /tmp/gvisor-sandbox-XXXXXX)

        # Extract the included Ubuntu 24.04 rootfs
        echo "Extracting Ubuntu 24.04 rootfs..."
        mkdir -p "$SANDBOX_DIR/rootfs"
        # Use sudo to preserve file ownership and permissions (especially for setuid binaries like sudo)
        sudo tar -xzpf "${{ github.action_path }}/ubuntu-24.04-rootfs.tar.gz" -C "$SANDBOX_DIR/rootfs"

        # Setup basic requirements for the container
        echo "Setting up container environment..."

        # Copy host's DNS configuration for network access
        sudo cp /etc/resolv.conf "$SANDBOX_DIR/rootfs/etc/resolv.conf"

        # Create parent directories for workspace mount point
        WORKSPACE_DIR="${{ github.workspace }}"
        WORKSPACE_PARENT=$(dirname "$WORKSPACE_DIR")
        sudo mkdir -p "$SANDBOX_DIR/rootfs$WORKSPACE_PARENT"

        # Create user in rootfs to match host user
        USER_ID=$(id -u)
        GROUP_ID=$(id -g)
        USER_NAME="${USER:-runner}"
        # HOME is always /home/username in our sandbox
        USER_HOME="/home/$USER_NAME"

        # Create home directory in rootfs
        sudo mkdir -p "$SANDBOX_DIR/rootfs$USER_HOME"
        # Set proper ownership for user's home directory
        sudo chown "$USER_ID:$GROUP_ID" "$SANDBOX_DIR/rootfs$USER_HOME"

        # Add user and group to rootfs
        echo "$USER_NAME:x:$USER_ID:$GROUP_ID:$USER_NAME:$USER_HOME:/bin/bash" | sudo tee -a "$SANDBOX_DIR/rootfs/etc/passwd" > /dev/null
        echo "$USER_NAME:x:$GROUP_ID:" | sudo tee -a "$SANDBOX_DIR/rootfs/etc/group" > /dev/null
        # Add user to shadow file (needed for PAM authentication)
        echo "$USER_NAME:*:19000:0:99999:7:::" | sudo tee -a "$SANDBOX_DIR/rootfs/etc/shadow" > /dev/null
        sudo chmod 0640 "$SANDBOX_DIR/rootfs/etc/shadow"

        # Configure passwordless sudo for the user (must exist in rootfs)
        # Use sudo to create the file with correct root ownership
        echo "$USER_NAME ALL=(ALL) NOPASSWD: ALL" | sudo tee "$SANDBOX_DIR/rootfs/etc/sudoers.d/$USER_NAME" > /dev/null
        sudo chmod 0440 "$SANDBOX_DIR/rootfs/etc/sudoers.d/$USER_NAME"
        sudo chown root:root "$SANDBOX_DIR/rootfs/etc/sudoers.d/$USER_NAME"

        # Create the user script inside the rootfs
        sudo tee "$SANDBOX_DIR/rootfs/entrypoint.sh" > /dev/null << 'SANDBOXED_SCRIPT_EOF'
        #!/bin/bash
        set -euo pipefail  # Exit on any error, undefined variable, or pipe failure
        cd "${{ github.workspace }}"
        ${{ inputs.run }}
        SANDBOXED_SCRIPT_EOF

        sudo chmod +x "$SANDBOX_DIR/rootfs/entrypoint.sh"

        # Generate OCI config using the pre-built binary
        # Write the env input to a temporary file to safely handle quotes and newlines
        cat > "$SANDBOX_DIR/additional_env.txt" << 'SANDBOXED_ENV_EOF'
        ${{ inputs.env }}
        SANDBOXED_ENV_EOF
        # Only pass the file if it's not empty
        if [ -s "$SANDBOX_DIR/additional_env.txt" ]; then
          "${{ github.action_path }}/generate-config" "$SANDBOX_DIR/additional_env.txt" > "$SANDBOX_DIR/config.json"
        else
          "${{ github.action_path }}/generate-config" > "$SANDBOX_DIR/config.json"
        fi

        # Run the container with runsc
        CONTAINER_ID="sandbox-$$-$(date +%s)"

        echo "Starting sandbox container..."
        cd "$SANDBOX_DIR"
        # Configure overlay based on persist-workspace-changes setting
        # Note: Running runsc with sudo but container processes still run as runner user (not root)
        if [ "${{ inputs.persist-workspace-changes }}" = "true" ]; then
          echo "::warning::Workspace changes will persist on the host filesystem"
          # Use overlay only for root filesystem, not for bind mounts (workspace)
          OVERLAY_FLAGS="--overlay2=root:self"
        else
          # Use overlay for all mounts (including workspace) for full isolation
          OVERLAY_FLAGS="--overlay2=all:self"
        fi
        # Add debug logging if RUNNER_DEBUG is set
        RUNSC_FLAGS="--network=host $OVERLAY_FLAGS --file-access-mounts=exclusive --allow-suid"
        if [ "${RUNNER_DEBUG:-0}" = "1" ]; then
          RUNSC_FLAGS="--debug --debug-log=/tmp/runsc-debug.log $RUNSC_FLAGS"
        fi
        # Run the sandbox and capture exit code
        EXIT_CODE=0
        sudo "${{ github.action_path }}/runsc" $RUNSC_FLAGS run "$CONTAINER_ID" || EXIT_CODE=$?

        # Clean up (always run, even if sandbox failed)
        cd /
        sudo rm -rf "$SANDBOX_DIR"

        # Exit with the same code as the sandbox
        if [ $EXIT_CODE -ne 0 ]; then
          echo "::error::Sandbox command failed with exit code $EXIT_CODE"
          exit $EXIT_CODE
        fi
